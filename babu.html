<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>babu</title>
    <style>
        @font-face {
            font-family: 'Berkeley Mono';
            src: url('/fonts/BerkeleyMono-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        body {
            margin: 0;
            padding: 60px 20px;
            background: #f5e6c8;
            color: #2c1810;
            font-family: 'Berkeley Mono', monospace;
            font-size: 16px;
            line-height: 1.75;
        }
        .container {
            max-width: 650px;
            margin: 0 auto;
        }
        header {
            margin-bottom: 60px;
        }
        header a {
            color: #5c4033;
            text-decoration: none;
            font-size: 14px;
        }
        header a:hover {
            text-decoration: underline;
        }
        h1 {
            font-size: 28px;
            font-weight: 700;
            margin-top: 20px;
        }
        p {
            margin-bottom: 24px;
        }
        a {
            color: #8b4513;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="/">← back</a>
            <h1>babu</h1>
        </header>

        <p>
            A good mentor and friend of mine's nickname: banana, monkey, rust. Babu.
        </p>

        <p>
            Names compress people into symbols. Symbols compress meaning into sound. Sound compresses time into memory.
        </p>

        <p>
            Thanks.
        </p>

        <pre class="ascii-art" style="font-size: 7px; line-height: 1.0; color: #5c4033; margin: 40px 0; opacity: 0.85;">
───────────────▄████████▄────────
─────────────▄█▀▒▒▒▒▒▒▒▀██▄──────
───────────▄█▀▒▒▒▒▒▒▒▒▒▒▒██──────
─────────▄█▀▒▒▒▒▒▒▄▒▒▒▒▒▒▐█▌─────
────────▄█▒▒▒▒▒▒▒▒▀█▒▒▒▒▒▐█▌─────
───────▄█▒▒▒▒▒▒▒▒▒▒▀█▒▒▒▄██──────
──────▄█▒▒▒▒▒▒▒▒▒▒▒▒▀█▒▄█▀█▄─────
─────▄█▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▀▒▒▒█▄────
────▄█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄───
───▄█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄──
──▄█▒▒▒▄██████▄▒▒▒▒▄█████▄▒▒▒▒█──
──█▒▒▒█▀░░░░░▀█─▒▒▒█▀░░░░▀█▒▒▒█──
──█▒▒▒█░░▄░░░░▀████▀░░░▄░░█▒▒▒█──
▄███▄▒█▄░▐▀▄░░░░░░░░░▄▀▌░▄█▒▒███▄
█▀░░█▄▒█░▐▐▀▀▄▄▄─▄▄▄▀▀▌▌░█▒▒█░░▀█
█░░░░█▒█░▐▐──▄▄─█─▄▄──▌▌░█▒█░░░░█
█░▄░░█▒█░▐▐▄─▀▀─█─▀▀─▄▌▌░█▒█░░▄░█
█░░█░█▒█░░▌▄█▄▄▀─▀▄▄█▄▐░░█▒█░█░░█
█▄░█████████▀░░▀▄▀░░▀█████████░▄█
─██▀░░▄▀░░▀░░▀▄░░░▄▀░░▀░░▀▄░░▀██─
██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██
█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█
█░▄░░░░░░░░░░░░░░░░░░░░░░░░░░░▄░█
█░▀█▄░░░░░░░░░░░░░░░░░░░░░░░▄█▀░█
█░░█▀███████████████████████▀█░░█
█░░█────█───█───█───█───█────█░░█
█░░▀█───█───█───█───█───█───█▀░░█
█░░░▀█▄▄█▄▄▄█▄▄▄█▄▄▄█▄▄▄█▄▄█▀░░░█
▀█░░░█──█───█───█───█───█──█░░░█▀
─▀█░░▀█▄█───█───█───█───█▄█▀░░█▀─
──▀█░░░▀▀█▄▄█───█───█▄▄█▀▀░░░█▀──
───▀█░░░░░▀▀█████████▀▀░░░░░█▀───
────▀█░░░░░▄░░░░░░░░░▄░░░░░█▀────
─────▀██▄░░░▀▀▀▀▀▀▀▀▀░░░▄██▀─────
────────▀██▄▄░░░░░░░▄▄██▀────────
───────────▀▀███████▀▀───────────
        </pre>

        <div class="footer">
            <canvas id="monkey-fractal" width="100" height="100" style="border: 1px solid #8b7355; cursor: pointer;"></canvas>
        </div>
    </div>

    <div id="modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(245,230,200,1); z-index: 1000; overflow: hidden; cursor: grab;">
        <div id="close-btn" style="position: fixed; top: 20px; right: 20px; cursor: pointer; font-size: 24px; color: #5c4033; z-index: 1001; background: rgba(245,230,200,0.8); padding: 5px 10px;">x</div>
        <div id="controls" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1001; display: flex; gap: 10px; font-family: 'Berkeley Mono', monospace; font-size: 12px; color: #5c4033; background: rgba(245,230,200,0.9); padding: 10px 15px; border: 1px solid #8b7355;">
            <span>drag to explore</span>
            <span>|</span>
            <span id="zoom-out" style="cursor: pointer;">-</span>
            <span id="zoom-level">100%</span>
            <span id="zoom-in" style="cursor: pointer;">+</span>
        </div>
        <canvas id="large-fractal" style="position: absolute;"></canvas>
    </div>

    <script>
        // Seeded random for consistent trees
        function seededRandom(seed) {
            return function() {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed / 0x7fffffff;
            };
        }

        let globalSeed = Date.now();

        function drawFractal(canvas, scale, customSeed, iterations) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const rand = seededRandom(customSeed || globalSeed);

            ctx.fillStyle = '#f5e6c8';
            ctx.fillRect(0, 0, width, height);

            // L-system parameters
            const axiom = 'F';
            const rules = { 'F': 'F[+F]F[-F][F]' };
            const angle = 20 + rand() * 15;
            const iters = iterations || 4;

            function generateLSystem(start, n) {
                let result = start;
                for (let i = 0; i < n; i++) {
                    let next = '';
                    for (let char of result) {
                        next += rules[char] || char;
                    }
                    result = next;
                }
                return result;
            }

            const lstring = generateLSystem(axiom, iters);
            const endpoints = [];
            const bananaSpots = [];

            function drawLSystem() {
                const stack = [];
                let x = width / 2;
                let y = height * 0.9;
                let heading = -90 * Math.PI / 180;
                let stepLength = 8 * scale;
                let thickness = 2 * scale;

                for (let char of lstring) {
                    if (char === 'F') {
                        const spiral = 0.02;
                        const steps = 10;

                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const spiralAngle = heading + spiral * Math.sin(t * Math.PI);
                            const nx = x + Math.cos(spiralAngle) * (stepLength / steps);
                            const ny = y + Math.sin(spiralAngle) * (stepLength / steps);

                            const taper = thickness * (1 - t * 0.3);
                            const brown = Math.floor(44 + t * 40);
                            ctx.strokeStyle = `rgba(${brown}, ${Math.floor(brown * 0.55)}, ${Math.floor(brown * 0.36)}, ${1 - t * 0.3})`;
                            ctx.lineWidth = Math.max(0.3, taper);

                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(nx, ny);
                            ctx.stroke();

                            x = nx;
                            y = ny;
                        }

                        endpoints.push({x, y});

                        if (rand() > 0.85) {
                            bananaSpots.push({x, y, angle: heading});
                        }

                    } else if (char === '+') {
                        heading += (angle + rand() * 10) * Math.PI / 180;
                    } else if (char === '-') {
                        heading -= (angle + rand() * 10) * Math.PI / 180;
                    } else if (char === '[') {
                        stack.push({x, y, heading, stepLength, thickness});
                    } else if (char === ']') {
                        const state = stack.pop();
                        ({x, y, heading, stepLength, thickness} = state);
                    }

                    stepLength *= 0.995;
                    thickness *= 0.98;
                }
            }

            drawLSystem();

            // Neural network connections
            ctx.strokeStyle = 'rgba(44, 24, 16, 0.1)';
            ctx.lineWidth = 0.2 * scale;
            for (let i = 0; i < endpoints.length - 1; i++) {
                if (rand() > 0.9) {
                    const j = Math.floor(rand() * endpoints.length);
                    const dist = Math.hypot(endpoints[i].x - endpoints[j].x,
                                           endpoints[i].y - endpoints[j].y);
                    if (dist < 50 * scale && dist > 10 * scale) {
                        ctx.beginPath();
                        ctx.moveTo(endpoints[i].x, endpoints[i].y);
                        ctx.lineTo(endpoints[j].x, endpoints[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Henon map strange attractor
            let hx = 0.1, hy = 0.1;
            const a = 1.4, b = 0.3;
            ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
            for (let i = 0; i < 100; i++) {
                const nx = 1 - a * hx * hx + hy;
                const ny = b * hx;
                hx = nx; hy = ny;

                const px = width/2 + hx * 100 * scale;
                const py = height/2 + hy * 100 * scale;

                ctx.beginPath();
                ctx.arc(px, py, 0.5 * scale, 0, Math.PI * 2);
                ctx.fill();
            }

            // Lifelike banana clusters
            function drawBanana(ctx, x, y, angle, size, ripeness, rand) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                const len = size * 12;
                const thick = size * 3;
                const curve = size * 4;

                // Banana body with bezier curve
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(
                    len * 0.3, -curve,
                    len * 0.7, -curve,
                    len, 0
                );
                ctx.bezierCurveTo(
                    len * 0.7, thick - curve,
                    len * 0.3, thick - curve,
                    0, thick * 0.3
                );
                ctx.closePath();

                // Gradient fill for 3D effect
                const grad = ctx.createLinearGradient(0, -curve, 0, thick);
                const yellow = ripeness > 0.7 ? '#f4d03f' : '#e6c229';
                const darkYellow = ripeness > 0.7 ? '#d4a017' : '#c9a227';
                grad.addColorStop(0, yellow);
                grad.addColorStop(0.3, '#f7dc6f');
                grad.addColorStop(0.7, yellow);
                grad.addColorStop(1, darkYellow);
                ctx.fillStyle = grad;
                ctx.fill();

                // Subtle outline
                ctx.strokeStyle = '#b8860b';
                ctx.lineWidth = size * 0.3;
                ctx.stroke();

                // Brown tip (stem end)
                ctx.beginPath();
                ctx.arc(0, thick * 0.15, size * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = '#5d4037';
                ctx.fill();

                // Brown tip (bottom end)
                ctx.beginPath();
                ctx.arc(len, 0, size * 0.8, 0, Math.PI * 2);
                ctx.fillStyle = '#3e2723';
                ctx.fill();

                // Bruise spots for realism
                if (ripeness > 0.6) {
                    for (let i = 0; i < Math.floor(ripeness * 4); i++) {
                        const spotX = len * (0.2 + rand() * 0.6);
                        const spotY = (rand() - 0.5) * thick * 0.5;
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, size * (0.3 + rand() * 0.4), 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(101, 67, 33, ${0.3 + rand() * 0.3})`;
                        ctx.fill();
                    }
                }

                // Highlight shine
                ctx.beginPath();
                ctx.ellipse(len * 0.5, -curve * 0.3, len * 0.25, size * 0.5, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fill();

                ctx.restore();
            }

            bananaSpots.forEach(spot => {
                const cluster = 3 + Math.floor(rand() * 4);
                const baseAngle = spot.angle + Math.PI / 2;

                for (let i = 0; i < cluster; i++) {
                    const fanAngle = baseAngle + (i - cluster / 2) * 0.25 + (rand() - 0.5) * 0.1;
                    const offsetX = Math.cos(fanAngle) * scale * 2 * i;
                    const offsetY = Math.sin(fanAngle) * scale * 2 * i + i * scale;
                    const ripeness = 0.5 + rand() * 0.5;

                    drawBanana(ctx, spot.x + offsetX, spot.y + offsetY, fanAngle + rand() * 0.2, scale * (0.8 + rand() * 0.4), ripeness, rand);
                }
            });

            // Particle flow
            const time = Date.now() * 0.001;
            endpoints.forEach((point, i) => {
                const orbitX = point.x + Math.cos(time + i) * 5 * scale;
                const orbitY = point.y + Math.sin(time + i) * 5 * scale;

                ctx.fillStyle = `rgba(139, 69, 19, ${0.5 + Math.sin(time + i) * 0.3})`;
                ctx.beginPath();
                ctx.arc(orbitX, orbitY, scale * 0.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        const smallCanvas = document.getElementById('monkey-fractal');
        const largeCanvas = document.getElementById('large-fractal');
        const modal = document.getElementById('modal');
        const closeBtn = document.getElementById('close-btn');
        const zoomIn = document.getElementById('zoom-in');
        const zoomOut = document.getElementById('zoom-out');
        const zoomLevel = document.getElementById('zoom-level');

        let panX = 0, panY = 0;
        let zoom = 1;
        let isDragging = false;
        let lastX, lastY;
        let currentSeed = null;
        let renderTimeout = null;

        // Calculate iterations based on zoom level - more detail as you zoom in
        function getIterations(z) {
            if (z < 0.5) return 3;
            if (z < 1) return 4;
            if (z < 2) return 5;
            if (z < 4) return 6;
            if (z < 8) return 7;
            if (z < 16) return 8;
            return 9;
        }

        // Calculate canvas size based on zoom - bigger canvas for more detail
        function getCanvasSize(z) {
            const base = Math.max(window.innerWidth, window.innerHeight);
            return Math.min(Math.floor(base * Math.max(z, 1) * 2), 8000);
        }

        function renderFractal() {
            const iterations = getIterations(zoom);
            const size = getCanvasSize(zoom);

            largeCanvas.width = size;
            largeCanvas.height = size;

            const scale = size / 150; // Scale relative to base size
            drawFractal(largeCanvas, scale, currentSeed, iterations);

            updateCanvasPosition();
        }

        function scheduleRender() {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderFractal, 150);
        }

        drawFractal(smallCanvas, 1);

        function updateCanvasPosition() {
            const size = largeCanvas.width;
            const scaledSize = size * zoom;
            largeCanvas.style.width = scaledSize + 'px';
            largeCanvas.style.height = scaledSize + 'px';
            largeCanvas.style.left = (window.innerWidth / 2 - scaledSize / 2 + panX) + 'px';
            largeCanvas.style.top = (window.innerHeight / 2 - scaledSize / 2 + panY) + 'px';
            zoomLevel.textContent = Math.round(zoom * 100) + '%';
        }

        smallCanvas.onclick = () => {
            currentSeed = Date.now();
            globalSeed = currentSeed;
            panX = 0;
            zoom = 1;
            renderFractal();
            panY = largeCanvas.height * zoom * 0.25;
            updateCanvasPosition();
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden';
        };

        closeBtn.onclick = (e) => {
            e.stopPropagation();
            modal.style.display = 'none';
            document.body.style.overflow = '';
        };

        // Dragging
        modal.onmousedown = (e) => {
            if (e.target === closeBtn || e.target.closest('#controls')) return;
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            modal.style.cursor = 'grabbing';
        };

        modal.onmousemove = (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            panX += dx;
            panY += dy;
            lastX = e.clientX;
            lastY = e.clientY;
            updateCanvasPosition();
        };

        modal.onmouseup = () => {
            isDragging = false;
            modal.style.cursor = 'grab';
        };

        modal.onmouseleave = () => {
            isDragging = false;
            modal.style.cursor = 'grab';
        };

        // Touch support
        modal.ontouchstart = (e) => {
            if (e.target === closeBtn || e.target.closest('#controls')) return;
            isDragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        };

        modal.ontouchmove = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const dx = e.touches[0].clientX - lastX;
            const dy = e.touches[0].clientY - lastY;
            panX += dx;
            panY += dy;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
            updateCanvasPosition();
        };

        modal.ontouchend = () => {
            isDragging = false;
        };

        // Zoom controls
        zoomIn.onclick = (e) => {
            e.stopPropagation();
            const oldZoom = zoom;
            zoom = Math.min(zoom * 1.5, 100);
            // Adjust pan to keep center
            panX = panX * (zoom / oldZoom);
            panY = panY * (zoom / oldZoom);
            scheduleRender();
            updateCanvasPosition();
        };

        zoomOut.onclick = (e) => {
            e.stopPropagation();
            const oldZoom = zoom;
            zoom = Math.max(zoom / 1.5, 0.2);
            panX = panX * (zoom / oldZoom);
            panY = panY * (zoom / oldZoom);
            scheduleRender();
            updateCanvasPosition();
        };

        // Mouse wheel zoom
        modal.onwheel = (e) => {
            e.preventDefault();
            const oldZoom = zoom;
            if (e.deltaY < 0) {
                zoom = Math.min(zoom * 1.15, 100);
            } else {
                zoom = Math.max(zoom / 1.15, 0.2);
            }
            // Zoom toward mouse position
            const rect = modal.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - rect.width / 2;
            const mouseY = e.clientY - rect.top - rect.height / 2;
            panX = mouseX - (mouseX - panX) * (zoom / oldZoom);
            panY = mouseY - (mouseY - panY) * (zoom / oldZoom);
            scheduleRender();
            updateCanvasPosition();
        };
    </script>
</body>
</html>
